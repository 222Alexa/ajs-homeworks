# AJS. Домашние задания (public)

###### tags: `netology` `advanced js`

**Важно**: нужно начиная с 3 занятия требовать 100% покрытия тестами кода и выполнения требований ESLint.

Почему: потому что неважно, куда они пойдут дальше (в React, Vue, Angular), там везде есть linting и авто-тесты. В больших компаниях просто код не примут, если сотрудник не написал авто-тесты для него.

В курсе JS рассматриваются только Unit-тесты и Mock'и. В следующем курсе (по HTML/JS) будут рассматривать E2E-тесты и работа с DOM.

[TOC]

## Занятие 1 Стандарты

### Задача 1.1 EcmaScript 6+

#### Легенда

Интернет-игра, для которой вы пишете фронтенд, решила реализовать систему лояльности. Вам нужно использовать возможности **ES6+** и **strict mode** решить задачу вычисления бонуса за покупку.

#### Описание

В массиве хранится стоимость товаров, которые пользователь готов купить. Рассчитайте величину бонуса, исходя из следующих условий: бонус составляет 5% от суммарной стоимости покупки выше 10 000 игровых баллов.

Стоимость товаров: `[200, 550, 4000, 23, 58, 5000, 485, 711]`

Важно: бонус может быть только целым числом.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

#### Подсказка

Используйте конструкцию `for ... of` и не используйте глобальных переменных и `var`.

### Задача 1.2 Template literals

#### Легенда

Вам дали достаточно сложную задачу: реализовать красивое отображение текущего баланса пользователя на русском языке. Используйте для этого **Template literals** и напишите соответствующую логику.

#### Описание

Реализуйте отображение сообщения для следующих тестовых данных:
|Баланс|Строка для отображения   |
|------|-------------------------|
| 523  |"Ваш баланс: 523 балла"  |
| 6000 |"Ваш баланс: 6000 баллов"|
| 5001 |"Ваш баланс: 5001 балл"  |

#### Подсказка

Правильный формат (балла, баллов, балл) вы должны определять на основании баланса программно. Подстановку баланса в строку выполняйте с использованием **Template Literals**

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

#### Подсказка

Используйте конструкцию `for ... of` и не используйте глобальных переменных и `var`.

### Задача 1.3 EcmaScript 5 (возвращаясь в прошлое)

#### Легенда

На время вы отвлеклись от разработки игры, т.к. вам выпала задача разработать виджет рейтинга ваших игроков для вставки на другие сайты. Поскольку другие сайты очень критично относятся к совместимости браузеров, перед вами поставили требование писать всё **в режиме совместимости с ES5** и **включенном строгом режиме**.

#### Описание

В массиве хранятся набранные баллы за очки в игре:`[74989, 74990, 74990, 62000, 58480, 61800]`. Найдите:
1. Самый лучший балл;
1. Средний игроков из топ-3.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 2 Рабочее окружение

### Задача 2.1 Создание package

#### Легенда

Итак, вы решили организовать разработку игры с использованием правильных инструментов, а именно что проект нужно создавать с помощью `npm`, управлять зависимостями и сборкой тоже с его помощью. 

#### Описание

Создайте проект на GitHub-проект, после чего с помощью `npm init` сгенерируйте package:
1. package name - defender-game
1. version - 1.0.0
1. description - "Browser based game"
1. entry point - index.js
1. test command - оставьте пустым
1. git repository - URL GitHub-проект репозитория 
1. keywords - game
1. author - ваше имя или псевдоним
1. license - ISC

Добавьте `.gitignore` в котором проигнорируйте каталог `node_modules`.

Отредактируйте `package.json`, добавив строку `"private": true`

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 2.2 Dev-зависимости

#### Легенда

Как вы уже видели, некоторые проекты требуют для своей работы совместимости со стандартом ES5. Но при этом есть большое желание использовать возможности ES6+. И для этого есть специальный инструмент, который позволяет осуществлять компиляцию кода на ES6+ в код на ES5 - (Babel)[https://babeljs.io]. Поэтому вы приняли следующее решение - писать всё на новейшей версии языка и с помощью Babel конвертировать всё в ES5, чтобы обеспечить себе наибольшее количество пользователей.

#### Описание

Ваша задача подключить Babel к проекту и настроить сборку с его использованием.

Установите Babel с помощью команды: `npm install --save-dev babel-cli babel-preset-env`.

Настройте скрипт запуска `build` для сборки с помощью `npm`. Для этого в секции `scripts` файла `package.json` пропишите:
```json
{
    ...
    "scripts": {
        ...
        "build": "babel src -d lib"
        ...
    }
}
```

Создайте конфиг `.babelrc`:
```json
{
    "presets": ["env"]
}
```

Создайте файл `src/app.js` со следующим содержимым:
```javascript
const characters = [
    {name: 'мечник', health: 10},
    {name: 'маг', health: 100},
    {name: 'маг', health: 0},
    {name: 'лучник', health: 0}
];

const alive = characters.filter(item => item.health > 0);
```

Удостоверьтесь, что проект собирается, если в консоли запустить команду `npm run build` и в каталоге lib отсутсвует код, несовместимый с ES5.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 2.3 ESLint

#### Легенда

Очень важно следить за качеством кода в вашем проекте и следовать единым принципам кодирования в команде. В этом нам поможет ещё один инструмент - ESLint.

#### Описание

Ваша задача "прикрутить" ESLint к проекту и настроить работу с его использованием.

Установка:
```shell
npm install --save-dev eslint
./node_modules/.bin/eslint --init
```

При инициализации конфиг файла выберите:
1. Use a popular style guide
1. Airbnb
1. React - No
1. Config format: json

Настройте скрипт запуска `lint` для `npm`. Для этого в секции `scripts` файла `package.json` пропишите:
```json
{
    ...
    "scripts": {
        ...
        "lint": "eslint src"
        ...
    }
}
```

Создайте файл `src/app.js` со следующим содержимым:
```javascript
const characters = [
    {name: 'мечник', health: 10},
    {name: 'маг', health: 100},
    {name: 'маг', health: 0},
    {name: 'лучник', health: 0}
];

const alive = characters.filter(item => item.health > 0);
```

Удостоверьтесь, что исправлены все ошибки проверки стиля.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 3 Unit-тестирование

### Описание установки

```shell
npm init # test command: jest --coverage
npm install --save-dev jest babel-jest babel-preset-env
```

Создать конфиг `.babelrc`:
```json
{
    "presets": ["env"]
}
```

Запуск тестов:
```shell
npm test
```

### Задача 3.1 Чистые функции

#### Легенда

Во время игры вам необходимо будет отображать полоску жизни над игровым персонажем. Для сигнализации пользователю вы решили ввести цветовую индикацию:
1. Здоровье более 50 - зелёный
1. Здоровье от 50 и до 15 - жёлтый
1. Менее 15 - красный

#### Описание

Реализуйте функцию, которая на вход принимает объект вида:
```javascript
{name: 'Маг', health: 90}
```
И возвращает ответ в виде одной из строк: `healthy`, `wounded`, `critical`

Сгенерируйте проект на базе `npm`. Подключите туда `jest` и напишите авто-тесты, которые обеспечивают 100% покрытие вашей функции.

Убедитесь, что вы обеспечили 100% покрытие тестами.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 3.2 Matchers

#### Легенда

Поскольку в рамках игры вы можете управлять несколькими героями, то во время "битвы" неплохо бы отображать уровень жизни, оставшейся у каждого героя в отсортированном порядке (наверху - самые здоровые). Необходимо сделать это и написать соответствующие авто-тесты.

#### Описание

Дан массив с информацией о героях, например:
```javascript
[
    {name: 'мечник', health: 10},
    {name: 'маг', health: 100},
    {name: 'лучник', health: 80},
]
```
В отсортированном порядке должно выглядеть следующим образом:
```javascript
[
    {name: 'маг', health: 100},
    {name: 'лучник', health: 80},
    {name: 'мечник', health: 10},
]
```

Используйте соответствующие "матчеры" (список приведён на странице [Документация по expect](https://jestjs.io/docs/ru/expect). Убедитесь, что вы обеспечили 100% покрытие тестами.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 3.3 Mocking

#### Легенда

Вы написали функцию, которая взаимодействует с функцией `fetchData` (достаточно тяжёлой, т.к. взаимодействует с удалённым веб-сервером). Вы хотите протестировать свою функцию (в том числе на то, как она обрабатывает ошибки) и, чтобы "отвязаться" от этой тяжёлой зависимости, решили использовать механизм "mocking'а".

#### Описание

```javascript=
// Демо-реализация функции fetchData:
function fetchLevel() {
    throw 'Mock this!';
}

// Ваша функция:
function getLevel() {
    const response = fetchData();
    
    // TODO: логика обработки
    if (response.status === 'ok') {
       return `Ваш текущий уровень: ${response.level}`; 
    }
    
    return `Информация об уровне временно недоступна`;
}
```

Сделайте моки для функции `fetchLevel` и напишите тесты таким образом, чтобы обеспечить 100% покрытие тестами функции `getLevel`.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 4 Синтаксически конструкции

**Важно**: код должен проходить ESLint без ошибок
**Важно**: тесты должны обеспечивать 100% покрытие функций

### Задача 4.1 try ... catch

#### Легенда

Ошибки случаются, такова жизнь. Но нужно уметь с ними работать. Ваши коллеги разработали форму, которая принимает от пользователя покупаемых единиц товара, вас же попросили написать функцию-валидатор, которая возвращает `true` - если всё ок, и `false` - если ввод не является числом в десятичной системе счисления.

#### Описание

Используйте возможности `try-catch` для преобразования строки в число. Не забудьте написать unit-тесты, которые обеспечивают покрытие всех веток (валидного и невалидного) ввода.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 4.2 Closures

#### Легенда

В рамках игры вы есть необходимость реализовать удобный глобальный поиск по всей системе. Для этого решено сделать специальный виджет, который прозводит этот самый поиск с использованием следующего синтаксиса: `фраза by:name` (пока не рассматривайте сценарий, что поля может не быть в объекте).

#### Описание

Массив объектов, по которым вам нужно производить поиск будет выглядеть следующим образом:
```javascript
[
    {name: 'маг', type: 'character', description: 'Персонаж, обладающий магическими способностями'},
    {name: 'заклинание', type: 'attack', description: 'Атака магическим заклинанием'},
    {name: 'урон', type: 'help', description: 'Страница описания элемента интерфейса'},
]
```

Реализуйте функцию `findBy`, которая будет вам возвращать замыкание, позволяющее осуществлять поиск по нужному полю.

Пример использования:
```javascript
const finder = findBy('name', 'урон');
const results = [
    {name: 'маг', type: 'character', description: 'Персонаж, обладающий магическими способностями'},
    {name: 'заклинание', type: 'attack', description: 'Атака магическим заклинанием'},
    {name: 'урон', type: 'help', description: 'Страница описания элемента интерфейса'},
].filter(finder);

console.log(results);
/*
[{
    name: 'урон',
    type: 'help',
    description: 'Страница описания элемента интерфейса'
}]
*/
```

Не забудьте написать unit-тесты на своё решение.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 4.3 Closures

#### Легенда

В рамках игры вы можете приобрести защитное заклинание для своих персонажей, которое будет уменьшать наносимый противником урон, распределяя равномерно его по всем вашим персонажам. Когда противник атакует одного из ваших персонажей, из жизни каждого персонажа вычитается равная доля урона.

Важно: если жизнь персонажа дошла до 0, на него больше не распространяется это правило (делится на количество живых). Если баллы атаки не делятся нацело на количество живых персонажей, то остаток достаётся тому, которого атакуют.

#### Описание

Массив ваших персонажей выглядит следующим образом:
```javascript
const characters = [
    {name: 'маг', health: 100},
    {name: 'лучник', health: 80},
    {name: 'мечник', health: 10},
]
```

Что нужно сделать: cделайте функцию, которая принимает на вход массив персонажей и на выходе возвращает массив из функций, которые и будут заниматься расчётом урона.

Как это должно выглядеть:
```javascript
/**
 * @param items - массив, с объектами ваших персонажей
 * @param shield - включена общая защита или нет 
 */
function setUpAttacks(items, shield = true) {
    const result = [];
    
    // TODO: ваш код
    
    return result; 
}

const characters = [
    {name: 'маг', health: 100},
    {name: 'лучник', health: 80},
    {name: 'мечник', health: 10},
]

const attacks[] = setUpAttacks(characters);

attacks[1](9); // атакуем лучника 9 баллами урона

console.log(characters)
/*
[
    {name: 'маг', health: 97},
    {name: 'лучник', health: 77},
    {name: 'мечник', health: 7},
]
*/
```


## Занятие 5. Свойства объектов, обёртки для примитивов

**Важно**: код должен проходить ESLint без ошибок
**Важно**: тесты должны обеспечивать 100% покрытие функций

### Задача 5.1 for ... in

#### Легенда

В рамках разработки игры периодически нужно печатать таблички, отображающие свойства объектов. Вам нужно реализовать функцию, которая для переданного объекта возвращает массив его свойств со значениями, отсортированный по свойствам (порядок сортировки свойств - второй аргумент).

#### Описание

Дан объект, например:
```javascript
{name: 'мечник', health: 10, level: 2, attack: 80, defence: 40}
```

Дан порядок сортировки свойств:
```javascript
["name", "level"]
```

После обработки вашей функцией:
```javascript
[
    {key: "name", value: "мечник"}, // порядок взят из массива с ключами
    {key: "level", value: 2}, // порядок взят из массива с ключами
    {key: "attack", value: 80}, // порядок по алфавиту (т.к. в массиве с ключами нет значения "attack")
    {key: "defence", value: 40}, // порядок по алфавиту (т.к. в массиве с ключами нет значения "defence")
    {key: "health", value: 10} // порядок по алфавиту (т.к. в массиве с ключами нет значения "health")
]
```

Т.е. сначала идёт сортировка по тому, как указано в массиве сортировки, для тех ключей, для которых в массиве сортировки нет записи, сортировка идёт в алфавитном порядке.

Используйте возможности `for-in` для перебора свойств объекта. Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функции, которую вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 5.2 Деструктуризация

#### Легенда

При выборе конкретного пресонажа на поле необходимо во время боя на экране отображать доступные варианты спец.атак для этого персонажа. Это вам и предстоит сделать.

#### Описание

Вам необходимо для панели выбора варианта атаки вытащить id, иконку и описание из объекта:
```json
{
    name: 'Лучник',
    type: 'Bowman',
    health: 50,
    level: 3,
    attack: 40,
    defence: 10,
    special: [
        {
            id: 8,
            name: 'Двойной выстрел',
            icon: 'http://...',
            description: 'Двойной выстрел наносит двойной урон'
        }, 
        { ... }
    ]	
}
```

Но для некоторых (ещё недоступных) атак описание является засекреченным и не отображается:

```json
{
        id: 8,
        description: 'Двойной выстрел наносит двойной урон',
        icon: 'http://...'
 }
```

Напишите функцию с аргументом-деструктор, которае извлекает массив с нужными полями (`id`, `description`, `icon`) из объекта, а если значения для поля `description` нет - устанавливает default'ное значение в 'Описание недоступно'. Функция должна возвращать извлечённый массив из объектов с тремя полями.

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функции, которую вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 5.3 Обёртки для примитивов

#### Легенда

Чтобы обеспечить пользователя быстрой информацией о текущем состоянии во время боя, необходимо написать функцию, которая над конкретным персонажем будет отображать краткое его текущее состояние, например: `Л(1) 40/100` - лучник первого уровня, осталось 40 жизней из 100.

#### Описание

Получая на вход объекты:
```json
{
    name: 'Лучник',
    type: 'Bowman',
    health: 50,
    level: 1,
    attack: 40,
    defence: 10
}
```
И используя знания о обёртке String, напишите функцию, которая генерирует краткое описание объекта в формате "😠 Л(1) ⚔40 🛡10 ❤50", где:
* 😠(U+1F620 - Bowman), 😡(U+1F620 - Swordsman), 🧐(U+1F9D0 - Magician) 👿 (U+1F47F - Daemon), 💀 (U+1F480 - Undead), 🧟 (U+1F9DF - Zombie) 
* Л - первая буква имени
* 40 - значение атаки
* 10 - значение защиты
* 50 - значение жизни

⚔ U+2694 - мечи
🛡 U+1F6E1 - щит
❤ U+2764 - сердце

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функции, которую вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 6. "Прототипы, конструкторы"

### Задача 6.1 Функция-конструктор

#### Легенда

В целях упрощения поддержки вашей игры и разрастающегося количества доступных персонажей, вы решили внедрить единые правила создания персонажей, и, конечно же, вам в этом помогут конструкторы

#### Описание

Реализуйте функцию-конструктор персонажей:
```javascript=
function Character(name, type) {
    // TODO: add logic here
    this.name = name;
    this.type = type;
}
```

Ваша функция-конструктор должна соответствовать следующим требованиям:
1. name - строка, min - 2 символа, max - 10
1. type - один из типов: Bowman, Swordsman, Magician, Daemon, Undead, Zombie

В случае, если передаются некорректные значения, функция конструктор должна выбрасывать ошибку и не 

В вашей функции автоматически должны устанавливаться значения следующих полей:
1. health: 100
1. level: 1
1. Атака/защита:
    1. Bowman - 25/25
    1. Swordsman - 40/10
    1. Magician - 10/40
    1. Undead - 25/25
    1. Zombie - 40/10
    1. Daemon - 10/40

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функции, которую вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 6.2 JSDoc

#### Легенда

Как только вы приступаете к решению вопросов организации своего кода, жёстко встаёт вопрос о его документировании для участников вашей команды. Для этого есть много инструментов, но вы ваш выбор остановился на [JSDoc](http://usejsdoc.org)

#### Описание JSDoc

Установите JSDoc в вашей проект с помощью следующей команды:
`npm install --save-dev jsdoc`

Создайте конфигурационный файл JSDoc - jsdoc.conf.json:
```json
{
  "source": {
    "include": ["js"]
  },
  "opts": {
    "encoding": "utf8",
    "destination": "./docs/",
    "recurse": true
  }
}
```
Создайте файл character.js с вашим приложением в каталоге js. В нём расположите заглушку функции:
```javascript
/**
 * <Общее описание>
 * 
 * @param <описание параметра>
 * @param <описание параметра>
 * 
 * @throws <описание генерируемой ошибки>
 */ 
function Character(name, type) {
    this.name = name;
    this.type = type;
}
```

Задайте скрипт npm в package.json:
`"doc": "jsdoc -c jsdoc.conf.json"`


Задокументируйте поведение функции-конструктора Character с использованием следующих doc-комментариев:
1. @param {<тип>} <имя> - описание параметра (см. (документацию)[http://usejsdoc.org/tags-param.html])
1. @throws {<тип>} - описание генерируемого исключения (см. (документацию)[http://usejsdoc.org/tags-throws.html])

Удостоверьтесь, что документация генирируется, запустив:
`npm run doc`

Добавьте каталог docs в .gitignore.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 6.3 Прототипы

#### Легенда

Теперь, когда у вас есть документированная функция-конструктор, вы можете воспользоваться возможностями прототипов для реализации общих функций для разных объектов. Давайте реализуем функцию, которая наносит "урон" объекту в результате атаки на него

#### Описание

В качестве отправной точки используйте следующую реализацию:
```javascript
function Character(name, type) {
    this.name = name;
    this.type = type;
    this.health = 100;
    this.attack = 10;
    this.defence = 40;
}
```

Реализуйте в прототипе Character функцию `damage(points)`, где `points` - это урон, наносимый игроку.

Итоговое изменение жизни персонажа (health) рассчитывается по формуле: points * (1 - defence / 100).

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функции, которую вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 7. "Классы, наследование"

### Задача 7.1 Классы, наследование

#### Легенда

Вы решили перейти на классы и реализовать нормальную иерархию, выделив в качестве базового класса класс Character, а для остальных персонажей создать классы, наследующиеся от него.

#### Описание

Реализуйте описанную иерархию классов: класс Character является родительским для всех остальных, 6 дочерних классов Bowerman, Swordsman, Magician, Daemon, Undead, Zombie от него наследуются, сами задавая свои характеристики.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 7.2 Методы

#### Легенда

Поскольку вы создавали классы для того, чтобы хранить в одном месте свойства объекта и его поведение, то пришла пора реализовать соответствующие методы.

#### Описание

Реализуйте в классе `Character` метод `levelUp`, который работает следующим образом:
1. На 1 повышает поле level
1. На 20% повышает показатели attack и defence
1. Приводит показатель health к значению 100

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 7.3 Get/Set

#### Легенда

Ваша команда решила внедрить в игру новую функцию - конкретному персонажу можно единожды включить режим `powerMode`. Что это значит? Показатели attack/defence/health персонажа увеличиваются вдвое, но ровно на три атаки.

#### Описание

Реализуйте получение показателей attack/defence/health через get/set', так, чтобы они учитывали включен режим powerMode. При этом powerMode тоже нужно реализовать через get/set так, чтобы включить его можно было только один раз.

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 8. "Контейнеры"

### Задача 8.1 Set

#### Легенда

Игрок может выбирать персонажей в команду на конкретный раунд исходя из их текущего состояния, уровня и стратегии игры. Нам необходимо не позволять ему добавлять в команду несколько раз одного и того же персонажа.

#### Описание

Создайте класс `Team` с методами `add`, `addAll` и `toArray`. Класс должен хранить данные о персонажах команды в поле класса `Set`.

Метод `add` должен добавлять выбранного персонажа в команду (объект класса `Character`). При этом такой объект уже существует в команде - дублирования происходить не должно, должна генерироваться ошибка.

Метод `addAll` должен иметь возможность добавлять произвольное количество персонажей (используйте rest-parameters) в команду. При этом задвоения быть не должно, ошибка генерироваться **не должна**.

Важно: ни методом `add`, ни методом `addAll` нельзя добавлять более 5 персонажей в команду.

Метод `toArray` должен производить конвертацию `Set` в массив.

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 8.2 Map

#### Легенда

Вы решили упорядочить работу с ошибками в своём приложении, а именно ввести цетрализованно числовой код ошибки и её описание. И при генерации любых ошибок в коде приложения брать их из централизованного хранилища.

#### Описание

Создайте свой класс ErrorRepository внутри которого храните Map, в котором ключ - это код ошибки (число), а значение - текстовое описание (человекочитаемое).

Реализуйте метод, позволяющий по коду получить текст ошибки, а в случае отсутствия подобного кода возвращать текст 'Unknown error'.

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 8.3 Map

#### Легенда

Давать возможность пользователю кастомизировать внешний вид приложения - достаточно хорошая идея. Поэтому вы решили также реализовать поддержку этой функциональности в своей игре.

#### Описание

У вас есть default'ные настройки, хранящиеся в Map'е:
1. 'theme': 'dark' (другие возможные значения - 'light', 'gray')
1. 'music': 'trance' (другие возможные значения - 'pop', 'rock', 'chillout', 'off')
1. 'difficulty': 'easy' (другие возможные значения - 'normal', 'hard', 'nightmare')

Напишите класс Settings, который содержит:
1. Набор настроек по умолчанию - хранить в Map'е
1. Набор пользовательских настроек (пользователь может установить конкретную настройку по имени и значению) - хранить в Map'е нужно только те настройки, которые пользователь установил
1. Get'тер `settings`, который возвращает Map, полученный путём наложения пользовательских настроек, на default'ные 

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 9. "Math, Regexp, ArrayBuffer"

### Задача 9.1 Math (log/trig)

#### Легенда

Мощь атаки магов и демонов привела к разбалансировке игрового мира. Поэтому вы ввели для игроков несколько новых правил и возможностей:
1. Сила урона зависит от расстояния (для Magician, Daemon) - линейно падает, а именно: на ближайшую клетку 100%, на 5 клетку от себя - 50%
1. Возможность насылать "дурман" на магов и демонов. При это их сила атаки падает уже не линейно, а в соответствии с log~2

#### Описание

Реализуйте классы Magician и Daemon с get/set stoned. При этом get/set attack должен учитывать логику, описанную в легенде.

Подсказка: используйте класс Math и наследование, чтобы не дублировать код.

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 9.2 Regexp

#### Легенда

Вы проанализировали логи вашей игры и заметили, что многие пользователи используют "мусорные" логины и различные непонятные символы не только в никнеймах, но и в именах. Необходимо с этим что-то делать! 

#### Описание

Реализуйте класс NameValidator с методом validate, который проверяет имя пользователя с помощью регулярных выражений на соответствие следующим правилам:
1. Допустимы только буквы, пробелы и символы тире
1. Имя не должно содержать подряд более нескольких пробелов, а также начинаться и заканчиваться пробелами (внимание - пробелами, а не пробельными символами)

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 9.3 ArrayBuffer

#### Легенда

Периодически данные приходят в бинарном формате и их необходимо преобразовать в какой-либо другой формат, например, строку json, чтобы потом распарсить в объект. Для этих манипуляций в том числе можно использовать объекты, которые предоставляются Web API - File и Blob, но прямая манипуляция ArrayBuffer будет в разы быстрее и эффективнее.

#### Описание

У вас есть функция getBuffer(), которая эмулирует создание объекта типа ArrayBuffer. Вам необходимо реализовать класс ArrayBufferConverter с методом load(), который может загружать данные и методом toString, который умеет переводить содержимое загруженного ArrayBuffer в строку.
```javascript
function getBuffer() {
    const data = '...';
    return (data => {
        const buffer = new ArrayBuffer(data.length * 2);
        const bufferView = new Uint16Array(buffer);
        for (let i = 0; i < input.length; i++) {
            bufferView[i] = input.charCodeAt(i);
        }
        return buffer;
    })(data);
}
```

- [ ] TODO: добавить JSON сюда (проверить функцию)

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 10. "Promises, async/await"

### Задача 10.1 Promises

#### Легенда

JavaScript живёт в асинхронном мире и большинство операций в нём так же выполняются асинхронно. Вы реализовали возможность экспорта сохранённого прогресса игры в виде JSON. Теперь нужно реализовать загрузку из файла.

#### Описание

Для вас реализованы функция-заглушка и класс, которая эмулируют чтение файла. Ваша задача - реализовать класс GameSavingLoader с методом load, который загружает данные, парсит их с помощью вызова метода json() и создаёт объект типа GameSaving.

Код-заглушка:
```javascript
class GameSavingData {
    constructor(data) {
        this.data = data;
    }
    
    json() {
        return new Promise((resolve, reject) => {
            // эмуляция обработки ArrayBuffer
            setTimeout(() => {
                resolve(String.fromCharCode.apply(null, new Uint16Array(this.data)));
            }, 1000);
        });
    }
}

function readGameSaving() {
    return new Promise((resolve, reject) => {
        // эмуляция чтения файла
        setTimeout(() => {
            const data = ``;
            return (input => {
                const buffer = new ArrayBuffer(input.length * 2);
                const bufferView = new Uint16Array(buffer);
                for (let i = 0; i < input.length; i++) {
                    bufferView[i] = input.charCodeAt(i);
                }
                resolve(buffer);
            })(data);
        }, 5000); 
    });
}
```

Пример использования функции (если бы это был синхронный код)
```json
const data = readGameSaving(); // возвращается Promise!
const value = data.json(); // возвращается Promise!
```

- [ ] TODO: добавить JSON сюда (проверить функцию)
- [ ] TODO: добавить спецификацию класса GameSaving

Важно: 

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете. Обратите внимание, что вы тестируете асинхронный код.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 10.2 async/await

#### Легенда

Вы устали от бесконечной цепочки .then().then().catch() и решили перейти на async/await.

#### Описание

Перепишите предыдущую задачу с использованием async/await. Не забудьте про try-catch для отлова ошибок.

Важно: 

Не забудьте написать unit-тесты, которые обеспечивают 100% покрытие функций и классов, которые вы тестируете. Обратите внимание, что вы тестируете асинхронный код.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 10.3 Testing Async code

#### Легенда

Асинхронный код - это здорово, но заглушки, которые были в предыдущих задачах всегда resolv'ятся, а в реальной жизни так бывает не всегда.

#### Описание

Используя механизмы Jest, замокайте функции-заглушки и классы-заглушки так, чтобы у вас была возможность протестировать как resolve, так и reject на каждом этапе.

Должно обеспечиваться 100% покрытие функций и классов, которые вы тестируете. Обратите внимание, что вы тестируете асинхронный код.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 11. "Символы, итераторы, генераторы"

### Задача 11.1 Символы & итераторы

#### Легенда

Для поддержки логики необходимо сделать объекты класса Team (команда, в которой хранятся персонажи противника на текущий раунд) итерируемыми. При итерации они должны выдавать персонажей.

#### Описание

Реализуйте итератор в классе Team, который по одному выдаёт персонажа.

### Задача 11.2 Итераторы

#### Легенда
- [ ] Подумать, может быть слишком сложно - итераторы с параметрами

Игроку легко, он сам определяет какого персонажа и каким персонажем атаковать. Для компьютера же нам придётся реализовать некоторую логику самостоятельно.

#### Описание

Вам необходимо написать итератор, который выбирает самого слабого из персонажей противника, учитывая атакующие способности персонажей компьютера (дальность атаки и направление атаки).

- [ ] TODO: продумать механику хранения данных и логику максимального урона.

Должно обеспечиваться 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 11.3 Генераторы
- [ ] Подумать, может быть слишком сложно - генераторы с параметрами

#### Легенда

Стратегия, реализованная в предыдущей задаче оказалась не слишком удачной, да и с итераторами работать тяжеловато. Поэтому вы решили реализовать новую стратегию - атаковать самых сильных персонажей противника.

#### Описание

Вам необходимо написать генератор, который последовательно обходит всех персонажей противника, отыскивая самого сильного.

- [ ] TODO: продумать механику хранения данных и логику самого сильного.

Должно обеспечиваться 100% покрытие функций и классов, которые вы тестируете.

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

## Занятие 12. "Модули"

### Задача 12.1 Webpack

#### Легенда

Ваш проект разросся и необходимо его разделить на модули. Модули помогают обеспечить изолированность кода и внести порядок в проект. Но для работы с модулями необходимо настроить загрузчик модулей (удостоверьтесь с помощью сервиса caniuse.com что модули поддерживаются не везде).

#### Описание

- [ ] Описание настройки Webpack с загрузкой модулей.
- [ ] Описание настройки Webpack для сборки.

### Задача 12.2 Import/Export

#### Легенда

Вы успешно настроили загрузку модулей с Webpack и сборку приложения. Пришло время всё грамотно разделить на модули!

#### Описание

Разделите всё приложение на модули:
1. Модуль Domain - где будет храниться логика предметной области (персонажи, атаки и т.д.)
1. Модуль Gameplay - где будут храниться настройки пользователя и взаимодействие с геймплеем
1. Модуль UI - отвечающий за отрисовку приложения
1. Модуль App - отвечающий за запуск приложения

Настройке экспорты и импорты, убедитесь, что приложение собирается, а полученная сборка запускается и работает.

Не забудьте про экспорт ключевых объектов в качестве default'ных.
- [ ] TODO: яснее расписать требования про дефолтные

:::info
В качестве результата пришлите проверяющему ссылку на ваш GitHub-проект.
:::

### Задача 12.3 Go online!

#### Легенда

Всё здорово, ваше приложение собирается и работает на локальном компьютере, пора разместить его в сети Интернет!

#### Описание

Соберите ваше приложение и опубликуйте его на сервисе GitHub Pages.
[Инструкция по публикации на GitHub Pages](https://pages.github.com)

:::info
В качестве результата пришлите проверяющему ссылку на ваш проект на GitHub Pages.
:::
